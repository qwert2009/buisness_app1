"""
PDS-Ultimate Advanced Memory System
======================================
–ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –º–∏—Ä–æ–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è.

–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø–∞–º—è—Ç–∏ (5 —Ç–∏–ø–æ–≤, –∞ –Ω–µ –ª–æ–≥–∏):

1. EPISODIC ‚Äî –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è, –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è, —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
   ¬´–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–∫–∞–∑–∞–ª 100 –±–∞–ª–∞–∫–ª–∞–≤ 15 —è–Ω–≤–∞—Ä—è¬ª

2. SEMANTIC ‚Äî –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è, –ø—Ä–∞–≤–∏–ª–∞, –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏
   ¬´–ë–∞–ª–∞–∫–ª–∞–≤—ã –æ–±—ã—á–Ω–æ –∑–∞–∫–∞–∑—ã–≤–∞—é—Ç –ø–∞—Ä—Ç–∏—è–º–∏ –æ—Ç 100 —à—Ç¬ª

3. PROCEDURAL ‚Äî –∫–∞–∫ –¥–µ–ª–∞—Ç—å –∑–∞–¥–∞—á–∏, –∞–ª–≥–æ—Ä–∏—Ç–º—ã, –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–µ–π—Å—Ç–≤–∏–π
   ¬´–î–ª—è —Ä–∞—Å—á—ë—Ç–∞ –ø—Ä–∏–±—ã–ª–∏: –¥–æ—Ö–æ–¥ - —Ä–∞—Å—Ö–æ–¥ = –æ—Å—Ç–∞—Ç–æ–∫ - –¥–æ—Å—Ç–∞–≤–∫–∞¬ª

4. STRATEGIC ‚Äî —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã, goals
   ¬´–û—Å–Ω–æ–≤–Ω–æ–π –ø–æ—Å—Ç–∞–≤—â–∏–∫ ‚Äî Alibaba, –∑–∞–ø–∞—Å–Ω–æ–π ‚Äî 1688.com¬ª

5. FAILURE ‚Äî –æ—à–∏–±–∫–∏, –Ω–µ—É–¥–∞—á–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è, —É—Ä–æ–∫–∏
   ¬´–ü–æ–∏—Å–∫ –ø–æ Google News –¥–∞–ª —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, –ª—É—á—à–µ DuckDuckGo¬ª

–ö–ª—é—á–µ–≤—ã–µ —Ñ–∏—á–∏ (–∏–∑ –¢–ó):
- Failure-driven learning: —Ö—Ä–∞–Ω–∏—Ç—å –æ—à–∏–±–∫–∏, —Å –∫–∞–∂–¥—ã–º —Ä–∞–∑–æ–º –ª—É—á—à–µ
- Time awareness: —É—á—ë—Ç –¥–∞—Ç—ã, –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏, —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
- Auto-summary & context compression: —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
- Memory embedding pruning: —É–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –∑–∞–ø–∏—Å–µ–π
- Semantic search (keyword + TF-IDF scoring)
- Confidence scoring: –∫–∞–∂–¥–∞—è –∑–∞–ø–∏—Å—å –∏–º–µ–µ—Ç –æ—Ü–µ–Ω–∫—É —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
- Decay: –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è —Ç–µ—Ä—è—é—Ç —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
"""

from __future__ import annotations

import hashlib
import math
from datetime import datetime
from typing import Any

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MEMORY TYPES (–∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


class MemoryType:
    """–¢–∏–ø—ã –ø–∞–º—è—Ç–∏ ‚Äî –ø–∞–º—è—Ç—å –ù–ï —Ä–∞–≤–Ω–æ –ª–æ–≥–∏."""
    EPISODIC = "episodic"        # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
    SEMANTIC = "semantic"        # –û–±–æ–±—â—ë–Ω–Ω—ã–µ –∑–Ω–∞–Ω–∏—è
    PROCEDURAL = "procedural"    # –ö–∞–∫ –¥–µ–ª–∞—Ç—å –∑–∞–¥–∞—á–∏
    STRATEGIC = "strategic"      # –°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è
    FAILURE = "failure"          # –û—à–∏–±–∫–∏ –∏ —É—Ä–æ–∫–∏
    FACT = "fact"                # –§–∞–∫—Ç—ã (backward compat)
    PREFERENCE = "preference"    # –ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    RULE = "rule"                # –ë–∏–∑–Ω–µ—Å-–ø—Ä–∞–≤–∏–ª–∞


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ADVANCED MEMORY ENTRY
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AdvancedMemoryEntry:
    """
    –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –µ–¥–∏–Ω–∏—Ü–∞ –ø–∞–º—è—Ç–∏.

    –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å MemoryEntry:
    - confidence: —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ (0.0-1.0)
    - decay_rate: —Å–∫–æ—Ä–æ—Å—Ç—å –∑–∞–±—ã–≤–∞–Ω–∏—è (0.0=–Ω–∏–∫–æ–≥–¥–∞, 1.0=–±—ã—Å—Ç—Ä–æ)
    - expiry: –¥–∞—Ç–∞ –∏—Å—Ç–µ—á–µ–Ω–∏—è (–¥–ª—è time-sensitive –¥–∞–Ω–Ω—ã—Ö)
    - context_hash: —Ö—ç—à –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (–¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è)
    - failure_count: —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –æ—à–∏–±–∞–ª—Å—è —Å —ç—Ç–æ–π –∑–∞–ø–∏—Å—å—é
    - success_count: —Å–∫–æ–ª—å–∫–æ —Ä–∞–∑ –∑–∞–ø–∏—Å—å –±—ã–ª–∞ –ø–æ–ª–µ–∑–Ω–∞
    - related_ids: —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –ø–∞–º—è—Ç–∏
    - source_quality: –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ (0.0-1.0)
    """

    def __init__(
        self,
        content: str,
        memory_type: str = MemoryType.EPISODIC,
        importance: float = 0.5,
        confidence: float = 0.8,
        tags: list[str] | None = None,
        source: str = "agent",
        metadata: dict | None = None,
        decay_rate: float = 0.1,
        expiry: datetime | None = None,
        source_quality: float = 0.7,
        chat_id: int | None = None,
    ):
        self.content = content
        self.memory_type = memory_type
        self.importance = min(1.0, max(0.0, importance))
        self.confidence = min(1.0, max(0.0, confidence))
        self.tags = tags or []
        self.source = source
        self.metadata = metadata or {}
        self.decay_rate = min(1.0, max(0.0, decay_rate))
        self.expiry = expiry
        self.source_quality = min(1.0, max(0.0, source_quality))
        self.chat_id = chat_id

        self.created_at = datetime.utcnow()
        self.last_accessed = self.created_at
        self.access_count = 0
        self.failure_count = 0
        self.success_count = 0
        self.related_ids: list[int] = []
        self.context_hash = self._compute_hash()
        self.db_id: int | None = None
        self.is_active = True

    def _compute_hash(self) -> str:
        """–•—ç—à –¥–ª—è –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏."""
        raw = f"{self.content}|{self.memory_type}".lower().strip()
        return hashlib.md5(raw.encode()).hexdigest()[:16]

    def touch(self) -> None:
        """–û–±–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è –¥–æ—Å—Ç—É–ø–∞ + —É–≤–µ–ª–∏—á–∏—Ç—å —Å—á—ë—Ç—á–∏–∫."""
        self.access_count += 1
        self.last_accessed = datetime.utcnow()

    def mark_success(self) -> None:
        """–ó–∞–ø–∏—Å—å –æ–∫–∞–∑–∞–ª–∞—Å—å –ø–æ–ª–µ–∑–Ω–æ–π."""
        self.success_count += 1
        # –ü–æ–≤—ã—à–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∏ –≤–∞–∂–Ω–æ—Å—Ç—å
        self.confidence = min(1.0, self.confidence + 0.05)
        self.importance = min(1.0, self.importance + 0.02)
        self.touch()

    def mark_failure(self) -> None:
        """–ó–∞–ø–∏—Å—å –ø—Ä–∏–≤–µ–ª–∞ –∫ –æ—à–∏–±–∫–µ."""
        self.failure_count += 1
        # –°–Ω–∏–∂–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
        self.confidence = max(0.0, self.confidence - 0.1)
        if self.failure_count >= 3:
            self.importance = max(0.1, self.importance - 0.1)

    def is_expired(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å: –∏—Å—Ç—ë–∫ –ª–∏ —Å—Ä–æ–∫ –∑–∞–ø–∏—Å–∏."""
        if self.expiry and datetime.utcnow() > self.expiry:
            return True
        return False

    def effective_importance(self) -> float:
        """
        –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å —Å —É—á—ë—Ç–æ–º decay (time awareness).

        –§–æ—Ä–º—É–ª–∞: importance * confidence * decay_factor * quality_factor
        - decay: —á–µ–º —Å—Ç–∞—Ä—à–µ, —Ç–µ–º –º–µ–Ω–µ–µ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ (–µ—Å–ª–∏ decay_rate > 0)
        - confidence: —á–µ–º —É–≤–µ—Ä–µ–Ω–Ω–µ–µ, —Ç–µ–º –≤–∞–∂–Ω–µ–µ
        - source_quality: —á–µ–º –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–µ–µ –∏—Å—Ç–æ—á–Ω–∏–∫, —Ç–µ–º –±–æ–ª—å—à–µ –≤–µ—Å
        """
        if self.is_expired():
            return 0.0

        # Time decay: exponential
        age_hours = (datetime.utcnow() -
                     self.created_at).total_seconds() / 3600
        decay_factor = math.exp(-self.decay_rate * age_hours / 720)
        # 720 —á–∞—Å–æ–≤ = 30 –¥–Ω–µ–π ‚Äî baseline

        # Access boost: —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–µ –Ω–µ –∑–∞–±—ã–≤–∞–µ—Ç—Å—è
        access_boost = min(0.3, self.access_count * 0.02)

        # Success/failure ratio
        total_uses = self.success_count + self.failure_count
        if total_uses > 0:
            success_ratio = self.success_count / total_uses
        else:
            success_ratio = 0.5  # neutral

        effective = (
            self.importance
            * self.confidence
            * decay_factor
            * (0.5 + 0.5 * self.source_quality)
            * (0.5 + 0.5 * success_ratio)
            + access_boost
        )
        return min(1.0, max(0.0, effective))

    def to_dict(self) -> dict:
        return {
            "content": self.content,
            "memory_type": self.memory_type,
            "importance": self.importance,
            "confidence": self.confidence,
            "effective_importance": self.effective_importance(),
            "tags": self.tags,
            "source": self.source,
            "metadata": self.metadata,
            "decay_rate": self.decay_rate,
            "expiry": self.expiry.isoformat() if self.expiry else None,
            "source_quality": self.source_quality,
            "created_at": self.created_at.isoformat(),
            "access_count": self.access_count,
            "failure_count": self.failure_count,
            "success_count": self.success_count,
            "context_hash": self.context_hash,
            "chat_id": self.chat_id,
        }

    def __repr__(self) -> str:
        eff = self.effective_importance()
        return (
            f"<AdvMemory [{self.memory_type}] "
            f"imp={self.importance:.1f} conf={self.confidence:.1f} "
            f"eff={eff:.2f}: {self.content[:40]}...>"
        )


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FAILURE MEMORY (Failure-Driven Learning)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FailureEntry(AdvancedMemoryEntry):
    """
    –ó–∞–ø–∏—Å—å –æ–± –æ—à–∏–±–∫–µ / –Ω–µ—É–¥–∞—á–Ω–æ–º —Ä–µ—à–µ–Ω–∏–∏.

    Failure-driven learning:
    - –•—Ä–∞–Ω–∏—Ç —á—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫
    - –•—Ä–∞–Ω–∏—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –æ—à–∏–±–∫–∏
    - –•—Ä–∞–Ω–∏—Ç –∫–∞–∫ –ù–ê–î–û –±—ã–ª–æ —Å–¥–µ–ª–∞—Ç—å (correction)
    - –ü—Ä–∏ –ø–æ—Ö–æ–∂–µ–π —Å–∏—Ç—É–∞—Ü–∏–∏ –∞–≥–µ–Ω—Ç –ù–ï –ø–æ–≤—Ç–æ—Ä—è–µ—Ç –æ—à–∏–±–∫—É
    """

    def __init__(
        self,
        content: str,
        error_context: str = "",
        correction: str = "",
        severity: str = "medium",  # low | medium | high | critical
        **kwargs,
    ):
        kwargs.setdefault("importance", 0.8)
        kwargs.setdefault("confidence", 0.9)
        kwargs.setdefault("decay_rate", 0.01)  # –û—à–∏–±–∫–∏ –Ω–µ –∑–∞–±—ã–≤–∞—é—Ç—Å—è –±—ã—Å—Ç—Ä–æ
        super().__init__(
            content=content,
            memory_type=MemoryType.FAILURE,
            **kwargs,
        )
        self.error_context = error_context
        self.correction = correction
        self.severity = severity
        self.tags.extend(["failure", "lesson", severity])

    def to_dict(self) -> dict:
        d = super().to_dict()
        d.update({
            "error_context": self.error_context,
            "correction": self.correction,
            "severity": self.severity,
        })
        return d


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ADVANCED WORKING MEMORY
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AdvancedWorkingMemory:
    """
    –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Ä–∞–±–æ—á–∞—è –ø–∞–º—è—Ç—å.

    –†–∞—Å—à–∏—Ä–µ–Ω–∏—è:
    - Goal integrity: –ø—Ä–æ–≤–µ—Ä–∫–∞ ¬´—è –≤—Å—ë –µ—â—ë —Ä–µ—à–∞—é –∏—Å—Ö–æ–¥–Ω—É—é —Ü–µ–ª—å?¬ª
    - Sub-goals: –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ü–µ–ª–∏ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á
    - Hypothesis tracking: –≥–∏–ø–æ—Ç–µ–∑—ã –∏ –∏—Ö –ø—Ä–æ–≤–µ—Ä–∫–∞
    - Context compression: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–∂–∞—Ç–∏–µ –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏
    - Time tracking: —Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ
    """

    MAX_SCRATCHPAD = 50
    MAX_TOOL_RESULTS = 20

    def __init__(self):
        self.primary_goal: str = ""
        self.sub_goals: list[dict[str, Any]] = []
        self.plan: list[dict[str, Any]] = []
        self.scratchpad: list[str] = []
        self.relevant_memories: list[AdvancedMemoryEntry] = []
        self.tool_results: list[dict[str, Any]] = []
        self.hypotheses: list[dict[str, Any]] = []
        self.iteration: int = 0
        self.context_vars: dict[str, Any] = {}
        self.start_time: datetime | None = None
        self.step_times: list[dict[str, Any]] = []
        self._goal_checks: list[dict[str, Any]] = []

    # ‚îÄ‚îÄ‚îÄ Goal Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def set_goal(self, goal: str) -> None:
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é —Ü–µ–ª—å."""
        self.primary_goal = goal
        self.sub_goals.clear()
        self.plan.clear()
        self.scratchpad.clear()
        self.tool_results.clear()
        self.hypotheses.clear()
        self.iteration = 0
        self.start_time = datetime.utcnow()
        self.step_times.clear()
        self._goal_checks.clear()

    def add_sub_goal(self, goal: str, priority: int = 0) -> None:
        """–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—É—é —Ü–µ–ª—å."""
        self.sub_goals.append({
            "goal": goal,
            "priority": priority,
            "status": "pending",
            "result": None,
            "created_at": datetime.utcnow().isoformat(),
        })
        self.sub_goals.sort(key=lambda g: g["priority"], reverse=True)

    def check_goal_integrity(self) -> dict[str, Any]:
        """
        Goal Integrity Check ‚Äî ¬´—è –≤—Å—ë –µ—â—ë —Ä–µ—à–∞—é –∏—Å—Ö–æ–¥–Ω—É—é —Ü–µ–ª—å?¬ª

        Returns:
            {"aligned": bool, "primary_goal": str, "current_focus": str}
        """
        current_focus = ""
        if self.plan:
            current_step = next(
                (s for s in self.plan if s["status"] == "pending"), None
            )
            if current_step:
                current_focus = current_step["step"]

        check = {
            "aligned": True,  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—á–∏—Ç–∞–µ–º aligned
            "primary_goal": self.primary_goal,
            "current_focus": current_focus,
            "iteration": self.iteration,
            "checked_at": datetime.utcnow().isoformat(),
        }
        self._goal_checks.append(check)
        return check

    # ‚îÄ‚îÄ‚îÄ Plan Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_plan_step(self, step: str, order: int = -1,
                      depends_on: list[int] | None = None) -> int:
        """–î–æ–±–∞–≤–∏—Ç—å —à–∞–≥ –ø–ª–∞–Ω–∞ (—Å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏ –¥–ª—è DAG)."""
        entry = {
            "step": step,
            "status": "pending",
            "result": None,
            "depends_on": depends_on or [],
            "started_at": None,
            "completed_at": None,
        }
        if 0 <= order < len(self.plan):
            self.plan.insert(order, entry)
        else:
            self.plan.append(entry)
        return len(self.plan) - 1

    def complete_step(self, index: int, result: str) -> None:
        """–û—Ç–º–µ—Ç–∏—Ç—å —à–∞–≥ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–π."""
        if 0 <= index < len(self.plan):
            self.plan[index]["status"] = "completed"
            self.plan[index]["result"] = result
            self.plan[index]["completed_at"] = datetime.utcnow().isoformat()
            self.step_times.append({
                "step": index,
                "duration_s": self._step_duration(index),
            })

    def fail_step(self, index: int, error: str) -> None:
        """–û—Ç–º–µ—Ç–∏—Ç—å —à–∞–≥ –∫–∞–∫ –Ω–µ—É–¥–∞–≤—à–∏–π—Å—è."""
        if 0 <= index < len(self.plan):
            self.plan[index]["status"] = "failed"
            self.plan[index]["result"] = error
            self.plan[index]["completed_at"] = datetime.utcnow().isoformat()

    def get_current_step(self) -> dict[str, Any] | None:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–π —à–∞–≥ (—Å —É—á—ë—Ç–æ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π)."""
        for i, step in enumerate(self.plan):
            if step["status"] != "pending":
                continue
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            deps = step.get("depends_on", [])
            all_deps_done = all(
                self.plan[d]["status"] == "completed"
                for d in deps if 0 <= d < len(self.plan)
            )
            if all_deps_done:
                step["started_at"] = datetime.utcnow().isoformat()
                return step
        return None

    def get_ready_steps(self) -> list[tuple[int, dict]]:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —à–∞–≥–∏ –≥–æ—Ç–æ–≤—ã–µ –∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—é (–¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–∞)."""
        ready = []
        for i, step in enumerate(self.plan):
            if step["status"] != "pending":
                continue
            deps = step.get("depends_on", [])
            all_deps_done = all(
                self.plan[d]["status"] == "completed"
                for d in deps if 0 <= d < len(self.plan)
            )
            if all_deps_done:
                ready.append((i, step))
        return ready

    def _step_duration(self, index: int) -> float:
        """–í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —à–∞–≥–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö."""
        step = self.plan[index]
        if step.get("started_at") and step.get("completed_at"):
            try:
                start = datetime.fromisoformat(step["started_at"])
                end = datetime.fromisoformat(step["completed_at"])
                return (end - start).total_seconds()
            except (ValueError, TypeError):
                pass
        return 0.0

    # ‚îÄ‚îÄ‚îÄ Hypothesis Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_hypothesis(self, hypothesis: str, confidence: float = 0.5) -> int:
        """–î–æ–±–∞–≤–∏—Ç—å –≥–∏–ø–æ—Ç–µ–∑—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏."""
        entry = {
            "hypothesis": hypothesis,
            "confidence": confidence,
            "status": "unverified",  # unverified | confirmed | refuted
            "evidence": [],
            "created_at": datetime.utcnow().isoformat(),
        }
        self.hypotheses.append(entry)
        return len(self.hypotheses) - 1

    def update_hypothesis(self, index: int, status: str,
                          evidence: str = "", confidence: float | None = None) -> None:
        """–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≥–∏–ø–æ—Ç–µ–∑—ã."""
        if 0 <= index < len(self.hypotheses):
            self.hypotheses[index]["status"] = status
            if evidence:
                self.hypotheses[index]["evidence"].append(evidence)
            if confidence is not None:
                self.hypotheses[index]["confidence"] = confidence

    # ‚îÄ‚îÄ‚îÄ Scratchpad & Tools ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_note(self, note: str) -> None:
        """–î–æ–±–∞–≤–∏—Ç—å –∑–∞–º–µ—Ç–∫—É –≤ scratchpad —Å auto-compression."""
        self.scratchpad.append(f"[iter {self.iteration}] {note}")
        if len(self.scratchpad) > self.MAX_SCRATCHPAD:
            # –°–∂–∏–º–∞–µ–º: –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ + –≤–∞–∂–Ω—ã–µ
            self.scratchpad = self.scratchpad[-self.MAX_SCRATCHPAD:]

    def add_tool_result(self, tool_name: str, result: str,
                        success: bool) -> None:
        """–ó–∞–ø–∏—Å–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞."""
        self.tool_results.append({
            "tool": tool_name,
            "result": result[:2000],
            "success": success,
            "iteration": self.iteration,
            "timestamp": datetime.utcnow().isoformat(),
        })
        if len(self.tool_results) > self.MAX_TOOL_RESULTS:
            self.tool_results = self.tool_results[-self.MAX_TOOL_RESULTS:]

    # ‚îÄ‚îÄ‚îÄ Context Summary ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def get_context_summary(self) -> str:
        """–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è LLM —Å goal integrity check."""
        parts = []

        if self.primary_goal:
            parts.append(f"üéØ –û–°–ù–û–í–ù–ê–Ø –¶–ï–õ–¨: {self.primary_goal}")

        if self.sub_goals:
            sub_lines = []
            for sg in self.sub_goals:
                emoji = {"pending": "‚è≥", "completed": "‚úÖ",
                         "failed": "‚ùå"}.get(sg["status"], "?")
                sub_lines.append(f"  {emoji} {sg['goal']}")
            parts.append("–ü–û–î–¶–ï–õ–ò:\n" + "\n".join(sub_lines))

        if self.plan:
            plan_lines = []
            for i, step in enumerate(self.plan):
                emoji = {"pending": "‚è≥", "completed": "‚úÖ",
                         "failed": "‚ùå"}.get(step["status"], "?")
                deps = step.get("depends_on", [])
                dep_str = f" [–∑–∞–≤–∏—Å–∏—Ç –æ—Ç: {deps}]" if deps else ""
                plan_lines.append(
                    f"  {emoji} {i + 1}. {step['step']}{dep_str}")
                if step["result"]:
                    plan_lines.append(f"     ‚Üí {step['result'][:100]}")
            parts.append("–ü–õ–ê–ù:\n" + "\n".join(plan_lines))

        if self.hypotheses:
            hyp_lines = []
            for h in self.hypotheses:
                emoji = {"unverified": "‚ùì", "confirmed": "‚úÖ",
                         "refuted": "‚ùå"}.get(h["status"], "?")
                hyp_lines.append(
                    f"  {emoji} {h['hypothesis']} "
                    f"(conf={h['confidence']:.1f})"
                )
            parts.append("–ì–ò–ü–û–¢–ï–ó–´:\n" + "\n".join(hyp_lines))

        if self.scratchpad:
            recent = self.scratchpad[-5:]
            parts.append("–ó–ê–ú–ï–¢–ö–ò:\n" + "\n".join(f"  ‚Ä¢ {n}" for n in recent))

        if self.relevant_memories:
            mem_lines = [
                f"  ‚Ä¢ [{m.memory_type}] {m.content[:80]}"
                for m in self.relevant_memories[:5]
            ]
            parts.append("–†–ï–õ–ï–í–ê–ù–¢–ù–´–ï –í–û–°–ü–û–ú–ò–ù–ê–ù–ò–Ø:\n" + "\n".join(mem_lines))

        if self.tool_results:
            recent_tools = self.tool_results[-3:]
            tool_lines = [
                f"  ‚Ä¢ {t['tool']}: "
                f"{'‚úÖ' if t['success'] else '‚ùå'} {t['result'][:80]}"
                for t in recent_tools
            ]
            parts.append("–ü–û–°–õ–ï–î–ù–ò–ï –î–ï–ô–°–¢–í–ò–Ø:\n" + "\n".join(tool_lines))

        return "\n\n".join(parts) if parts else "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞."

    def reset(self) -> None:
        """–ü–æ–ª–Ω—ã–π —Å–±—Ä–æ—Å."""
        self.primary_goal = ""
        self.sub_goals.clear()
        self.plan.clear()
        self.scratchpad.clear()
        self.relevant_memories.clear()
        self.tool_results.clear()
        self.hypotheses.clear()
        self.iteration = 0
        self.context_vars.clear()
        self.start_time = None
        self.step_times.clear()
        self._goal_checks.clear()
